package com.magix.pistarlink

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.Intent
import android.os.Binder
import android.os.Build
import android.os.IBinder
import android.util.Log
import androidx.core.app.NotificationCompat
import com.magix.pistarlink.ui.home.HomeFragment
import com.magix.pistarlink.ui.home.MyVpnServiceCallback
import com.magix.pistarlink.ui.home.WgTunnel
import com.wireguard.android.backend.GoBackend
import com.wireguard.android.backend.GoBackend.VpnService
import com.wireguard.android.backend.Tunnel
import com.wireguard.config.Config
import com.wireguard.config.InetEndpoint
import com.wireguard.config.InetNetwork
import com.wireguard.config.Interface
import com.wireguard.config.Peer
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.cancelChildren
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.net.InetAddress
import kotlin.coroutines.cancellation.CancellationException

class MyVpnService : Service() {

    private var tunnel: WgTunnel? = null
    private var callback: MyVpnServiceCallback? = null
    private lateinit var dbHandler: DbHandler
    private val binder = MyBinder()

    inner class MyBinder : Binder() {
        fun getService(): MyVpnService = this@MyVpnService
    }

    companion object {
        private var callback: MyVpnServiceCallback? = null

        fun setCallback(cb: HomeFragment) {
            callback = cb
        }

        fun clearCallback() {
            callback = null
        }
    }

    override fun onCreate() {
        super.onCreate()
        dbHandler = DbHandler(this)
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        connectWireguard()
        return START_STICKY
    }

    fun connectWireguard() {
        Log.d("Wireguard-Handler", "Connecting Wireguard as a foreground service")

        // Create and start foreground service
        val notification = createNotification() // Function to create the notification for the foreground service
        startForeground(1, notification)  // Notification ID is 1, you can use any unique ID here.

        tunnel = WgTunnel()
        val intentPrepare: Intent? = GoBackend.VpnService.prepare(this)

        // Handle VPN permission if necessary
        if (intentPrepare != null) {
            // Prompt the user for permission (launch the VPN preparation UI)
            startActivity(intentPrepare.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK))
            return  // Wait for the result before proceeding
        }

        // Start VPN connection in background
        CoroutineScope(Dispatchers.IO).launch {
            try {
                // Fetch values from the database
                val privateKey = dbHandler.getConfiguration("PrivateKey") ?: ""
                val addresses = dbHandler.getConfiguration("Address") ?: ""
                val address1 = addresses.split(",").getOrNull(0)?.trim() ?: ""
                val address2 = addresses.split(",").getOrNull(1)?.trim() ?: ""
                val dns = dbHandler.getConfiguration("DNS") ?: ""
                val publicKey = dbHandler.getConfiguration("PublicKey") ?: ""
                val presharedKey = dbHandler.getConfiguration("PresharedKey") ?: ""
                val endpoint = dbHandler.getConfiguration("Endpoint") ?: ""
                val allowedIPs = dbHandler.getConfiguration("AllowedIPs") ?: "0.0.0.0/0"
                val persistentKeepalive = dbHandler.getConfiguration("PersistentKeepalive")?.toIntOrNull() ?: 25

                // Build the interface and peer configurations
                val interfaceBuilder = Interface.Builder()
                val peerBuilder = Peer.Builder()

                // Set up the WireGuard VPN using the retrieved configurations
                tunnel?.let {
                    GoBackend(this@MyVpnService).setState(
                        it,
                        Tunnel.State.UP,
                        Config.Builder()
                            .setInterface(
                                interfaceBuilder
                                    .addAddress(InetNetwork.parse(address1))  // Address from DB
                                    .addAddress(InetNetwork.parse(address2))  // Address from DB
                                    .parsePrivateKey(privateKey)  // Private key from DB
                                    .addDnsServer(InetAddress.getByName(dns))  // DNS from DB
                                    .build()
                            )
                            .addPeer(
                                peerBuilder
                                    .addAllowedIp(InetNetwork.parse(allowedIPs))  // Allowed IPs from DB
                                    .setEndpoint(InetEndpoint.parse(endpoint))  // Endpoint from DB
                                    .parsePublicKey(publicKey)  // Public key from DB
                                    .parsePreSharedKey(presharedKey)  // Pre-shared key from DB
                                    .setPersistentKeepalive(persistentKeepalive)  // Persistent keepalive from DB
                                    .build()
                            )
                            .build()
                    )
                }

                // If successful, mark VPN as connected and update the UI
                withContext(Dispatchers.Main) {
                    dbHandler.addConfiguration("lastVPNUsed", "Wireguard")
                    dbHandler.updateConfiguration("lastVPNUsed", "Wireguard")

                    // Fetch the acquired IPv4
                    val acquiredIPv4 = HomeFragment().getVpnIPv4Address()
                    acquiredIPv4?.let {
                        // Update the acquired IPv4 if found
                    }

                    // Notify the fragment about the status update
                    callback?.onVpnStatusUpdated(true) // Pass the VPN status
                    Log.d("Wireguard-Handler", "VPN connected successfully. Status updated.")
                }

            } catch (e: Exception) {
                e.printStackTrace()
                Log.e("Wireguard-Handler", "Failed to establish the VPN connection: ${e.message}")
            }
        }
    }

    // Helper function to create the notification for the foreground service
    private fun createNotification(): Notification {
        val notificationChannelId = "WireguardForegroundService"
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                notificationChannelId,
                "Wireguard VPN Service",
                NotificationManager.IMPORTANCE_DEFAULT
            )
            val manager = getSystemService(NotificationManager::class.java)
            manager.createNotificationChannel(channel)
        }

        val notificationIntent = Intent(this, MainActivity::class.java)
        val pendingIntent = PendingIntent.getActivity(
            this,
            0,
            notificationIntent,
            PendingIntent.FLAG_IMMUTABLE
        )

        return NotificationCompat.Builder(this, notificationChannelId)
            .setContentTitle("Wireguard VPN")
            .setContentText("Wireguard VPN is running")
            .setSmallIcon(R.drawable.wg_icon)
            .setContentIntent(pendingIntent)
            .build()
    }

    override fun onBind(intent: Intent?): IBinder? {
        return binder
    }

    fun disconnectWireguard() {
        CoroutineScope(Dispatchers.IO).launch {
            try {
                tunnel?.let {
                    // Log current state for clarity
                    Log.d("Wireguard-Handler", "Attempting to disconnect VPN...")

                    // Step 1: Close the VPN interface (set state to DOWN)
                    val newState = GoBackend(this@MyVpnService).setState(it, Tunnel.State.DOWN, null)

                    // Log the state transition for clarity
                    Log.d("Wireguard-Handler", "VPN state changed to: $newState")

                    // Step 2: Verify the state is changed to DOWN
                    if (newState == Tunnel.State.DOWN) {
                        // Step 3: Stop all coroutines/threads related to VPN operation
                        this.coroutineContext.cancelChildren() // Cancels all children coroutines within the current scope

                        withContext(Dispatchers.Main) {
                            Log.d("Wireguard-Handler", "VPN disconnected successfully.")

                            // Step 4: Stop the foreground service and remove the notification
                            stopForeground(true)  // Stop the foreground service and remove the notification

                            // Step 5: Stop the service itself
                            stopSelf()  // Stop the service after disconnection
                        }
                    } else {
                        Log.e("Wireguard-Handler", "Failed to change VPN state to DOWN.")
                    }
                } ?: run {
                    // Handle the case where the tunnel is null
                    Log.e("Wireguard-Handler", "Tunnel is null. Cannot disconnect VPN.")
                }
            } catch (e: CancellationException) {
                Log.d("Wireguard-Handler", "Disconnection was interrupted.")
            } catch (e: Exception) {
                e.printStackTrace()
                Log.e("Wireguard-Handler", "Failed to disconnect the VPN: ${e.message}")
            }
        }
    }

    override fun onDestroy() {
        disconnectWireguard() // Ensure the VPN is disconnected before destroying the service
        super.onDestroy()
    }

    fun setCallback(callback: MyVpnServiceCallback) {
        // Set the callback for the service
        this.callback = callback
    }
}
